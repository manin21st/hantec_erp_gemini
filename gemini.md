# [HANTEC ERP] 파워빌더 10 -> 10.5 마이그레이션 핸드북

## 0. 문서 개요

이 문서는 한텍 ERP 시스템의 파워빌더 10 버전을 10.5로 마이그레이션하는 프로젝트의 전반적인 지침과 결과물을 관리하는 핸드북입니다.

- **주요 구성 (작업 흐름)**:
    1.  **핵심 대원칙**: 프로젝트의 기본 원칙을 숙지합니다.
    2.  **패턴 분석 원칙**: 소스 코드 분석 및 패턴 정의의 기준을 정립합니다.
    3.  **마이그레이션 최종 패턴**: 분석된 패턴을 목록화하고 상세 내용을 정의합니다.
        `->` 이 패턴들은 `PBMigrator` 개발의 핵심 명세가 됩니다.
    4.  **PBMigrator**: 정의된 패턴에 따라 마이그레이션을 자동화하는 도구의 사용법과 명세를 안내합니다.
    5.  **작업 관리**: 모든 작업의 이력을 추적하고 관리하는 방법을 안내합니다.

- **핵심 목표**:
    - 모든 소스 코드가 새로운 파워빌더 10.5 환경에서 완벽하게 호환되도록 보장합니다.
    - 자동화된 마이그레이션을 통해 작업의 일관성과 효율성을 극대화합니다.

---



## 1. 핵심 대원칙

> **"기존 로직과 기능에 단 1%의 변경도 없이, 새 버전(10.5)에서 완벽하게 호환되도록 한다."**

- **파워빌더 10.5 문법 준수**: 모든 코드는 파워빌더 10.5 문법에 맞게 작성되어야 하며, 이로 인해 발생하는 `Syntax Error`는 없어야 한다.
- **최소 변경의 원칙**: '개선'이 아닌 '호환'을 목표로 한다. 기능 및 로직에 영향을 줄 수 있는 임의의 코드 수정, 구조 변경, 리팩토링을 **절대 금지**한다.
- **참조용 소스 보호**: `source/_sample`, `source/_reference`, `target/_sample`, `target/_reference` 폴더의 파일들은 패턴 분석을 위한 원본 참조 자료이므로, 마이그레이션 작업 중 절대로 수정되어서는 안 된다.
- **변경 유형 제한**: 오직 **Type 1** 변경만 허용한다.
    - **Type 1 (호환성 수정)**: 인코딩, 줄바꿈, 미지원 함수 등 실행 환경 변화로 인해 발생하는 컴파일/실행 오류를 해결하기 위한 **필수 수정**.
    - **Type 2 (임의 개선)**: 상속 구조 변경, UI 패턴 통일, 로직 '개선' 등 기존 동작에 영향을 줄 수 있는 모든 **임의 수정. (원칙적 금지)**

---

## 2. 패턴 분석 원칙

1.  **실행 코드 기반 분석**: 오직 **실행되는(Active) 코드**의 변경점만을 패턴 분석의 근거로 삼는다. 주석 처리된 코드는 분석에서 제외한다.
2.  **반복성 교차 검증**: 하나의 파일에서 발견된 변경 유형은, 최소 **2개 이상의 다른 파일**에서 동일한 규칙으로 반복되는지 교차 검증을 거친 후에만 패턴으로 정의한다.
3.  **사실 기반의 명확한 근거 제시**: 추측이나 부정확한 기억이 아닌, 실제 파일의 내용에만 100% 기반하여 패턴을 도출하고 설명한다.

---

## 3. 마이그레이션 최종 패턴

> **현재 모든 마이그레이션 로직은 단일 규칙 `P-01`로 통합 및 표준화되었습니다.**

-   **P-01: 부모-자식 윈도우 동기화 (CRITICAL)**
    -   **(목적)**: PowerBuilder 10.5 환경에서 새로운 부모 윈도우의 정의에 맞춰, 자식 윈도우에 불필요하게 남은 컨트롤과 이벤트를 자동으로 **주석 처리**하여 컴파일 오류를 방지하고, 수동 검토 및 복구를 용이하게 합니다.
    -   **(처리 방안)**:
        1.  자식 윈도우 소스에서 상속 관계(`global type ... from ...`)를 파악합니다.
        2.  `target/_reference` 폴더에서 최신 부모 윈도우의 소스를 읽어와 컨트롤 이름 목록을 추출합니다.
        3.  자식 윈도우의 컨트롤 이름 목록과 부모 윈도우의 컨트롤 이름 목록을 비교하여, 부모에 더 이상 존재하지 않는 '오래된 컨트롤(obsolete control)'을 식별합니다.
        4.  오래된 컨트롤이 하나라도 발견되면, 변환될 파일의 **3번째 줄**에 아래와 같은 설명 주석을 **한 번만** 추가합니다.
            -   `//& PBMigrator에 의해 주석 처리된 더 이상 사용되지 않는 컨트롤 및 이벤트 (YYYY-MM-DD).`
        5.  자식 윈도우 소스 코드에서, 식별된 각 '오래된 컨트롤'의 정의 블록(`type...end type`)과 모든 관련 이벤트 블록(`event...end event`)을 찾아, 해당 블록의 **모든 라인 앞에 `//& `를 붙여** 주석 처리합니다.
    -   **(파일 포맷)**: 최종 저장되는 파일은 **U-DOS (UTF-16 LE with BOM)** 형식과 **CRLF** 줄바꿈을 사용해야 합니다.
    -   **(상태)**: `engine.py`의 `apply_rules` 메서드에 절차적, 라인 기반 로직으로 구현 완료. `spec.py`는 컨트롤 이름 목록을 추출하는 헬퍼 함수를 제공합니다.

---

## 4. PBMigrator: 자동 마이그레이션 도구

### 4.1. 개발 목표 및 현황

- **목표**: `specification.md` 명세서에 따라, PowerBuilder 10 소스를 10.5 버전으로 자동 변환하는 GUI 애플리케이션 `PBMigrator`를 개발한다.
- **핵심 역할**:
    - `gemini.md`의 **'3. 마이그레이션 최종 패턴'** 에 정의된 모든 규칙을 자동화하여 적용한다.
    - 사용자가 변환 과정을 시각적으로 확인하고 제어할 수 있는 UI를 제공한다.
- **작업 상태**: `source/_sample` 폴더의 신규 소스 분석을 통해 마이그레이션 패턴을 지속적으로 개선하고 있으며, 발견된 패턴을 `PBMigrator` 엔진에 반영하는 작업을 진행 중입니다.

### 4.2. 사용법

모든 마이그레이션 작업은 `PBMigrator` GUI 프로그램을 통해 진행하는 것을 원칙으로 한다.

**1단계: 프로그램 실행 및 파일 선택**
- `dist` 폴더의 `PBMigrator.exe`를 실행하여 프로그램을 시작한다.
- 프로그램은 시작 시 자동으로 `source` 폴더 하위의 모든 `.srw` 파일을 읽어 좌측 '파일 목록'을 채운다. (`_`로 시작하는 폴더는 제외)
- 목록에서 변환할 파일을 한 개 또는 여러 개 선택한다.

**2단계: 변환 실행 (두 가지 방법)**

**방법 A: 단일 파일 변환 (즉시 확인 및 저장)**
1.  '파일 목록'에서 **하나의 파일**을 선택한다.
2.  '설정 및 실행' 탭의 우측 하단에 있는 원본 코드 뷰어에 해당 파일의 내용이 표시되는 것을 확인한다.
3.  **'소스 비교' 탭을 클릭한다.**
4.  탭을 클릭하는 즉시, 선택된 파일에 대한 변환이 자동으로 실행되고 `target` 폴더에 저장된다.
5.  '소스 비교' 탭으로 자동 전환되며, 좌측(원본)과 우측(변환 후)의 코드 비교 결과를 즉시 확인할 수 있다.
6.  상세한 변환 내역은 '설정 및 실행' 탭의 'Log' 창에 표시된다.

**방법 B: 일괄 변환 (여러 파일 동시 처리)**
1.  '파일 목록'에서 **여러 개의 파일**을 선택한다. (Ctrl 또는 Shift 키 사용)
2.  '설정 및 실행' 탭의 'Controls' 영역 우측에 있는 **[변환 실행]** 버튼을 클릭한다.
3.  진행률을 표시하는 팝업창이 나타나며, 선택된 모든 파일에 대한 변환 및 저장이 순차적으로 진행된다.
4.  모든 작업이 완료되면, 'Log' 창에 모든 파일에 대한 상세한 변환 결과가 한 번에 출력된다.

**3단계: 결과 확인**
- **변환된 파일**: `target` 폴더에 원본과 동일한 경로 구조로 변환된 `.srw` 파일이 생성된다. (파일 형식 처리는 P-01 참조)
- **처리 로그**: 'Log' 창에서 각 파일의 규칙 적용 내역, 성공/실패 여부 등 상세한 정보를 확인할 수 있다. (별도의 `.md` 보고서 파일은 더 이상 생성되지 않음)

### 4.3. 빌드 및 재배포

`PBMigrator`의 소스 코드를 수정한 후, 사용자가 직접 실행할 수 있는 `.exe` 파일을 만들려면 `PBMigrator.spec` 파일을 사용하여 빌드를 진행합니다.

**권장 사항: 클린 빌드 (Clean Build)**

- 빌드를 실행하기 전, 이전 빌드의 캐시나 결과물이 남아있지 않도록 **기존의 `build` 및 `dist` 폴더를 삭제**하는 것을 권장합니다. 이렇게 하면 잠재적인 캐시 문제를 방지하고 가장 안정적인 결과물을 얻을 수 있습니다.

**빌드 절차**

1.  **전제 조건**: 로컬 시스템에 **Python**과 **PyInstaller** 라이브러리가 설치되어 있어야 합니다.
2.  **빌드 실행**: 프로젝트 최상위 폴더(`hantec_erp_gemini`)에서 다음 명령어를 실행합니다.

    ```shell
    py -m PyInstaller PBMigrator.spec
    ```

3.  **결과 확인**: 빌드가 성공하면 `dist` 폴더에 `PBMigrator.exe` 파일이 생성됩니다.
    - `PBMigrator.spec` 파일에는 `console=False` 설정이 적용되어 있으므로, 실행 시 불필요한 명령 프롬프트(cmd) 창이 나타나지 않습니다.

**중요 사항**:
- 빌드 실패 시 `PermissionError`가 발생한다면, 이전에 실행했던 `PBMigrator.exe`가 종료되지 않았거나 다른 프로그램이 파일을 잠근 상태일 수 있습니다. `dist` 폴더의 `.exe` 파일을 수동으로 삭제한 후 다시 빌드를 시도하십시오.

---

## 5. 작업 관리 (Management)

- **M-01: 버전 관리 (CRITICAL)**
    - 모든 작업 완료 후, 변경 사항은 반드시 GitHub 저장소에 업로드(Push)하여 최신 상태를 유지한다.
    - **`main` 브랜치를 단일 브랜치로 사용하며, 다른 브랜치(예: `master`)는 생성하거나 사용하지 않는다.**
    - `source`, `target`, 그리고 `test` 폴더는 모두 버전 관리 대상으로, 변환 전 원본과 변환 후 결과물, 그리고 테스트 관련 파일을 함께 추적하여 관리한다.

- **M-02: 진행 상황 기록 (CRITICAL)**
    - 모든 작업 내역은 **`progress.yml`** 파일에 YAML 형식으로 기록하여 관리한다.
    - 각 작업은 `PBMigrator` 실행 단위(파일 변환 및 저장) 또는 주요 결정 사항을 기준으로 로그가 기록된다.
    - 각 로그 항목은 `timestamp`, `status`, `target`, `description`, `worker` 등의 정보를 포함한다.
    - **새 작업 세션 시작 시, 가장 먼저 이 파일을 확인하여 마지막 작업 상태를 파악하고 다음 작업을 결정한다.**

- **M-03: 사용자 요청사항 관리 (CRITICAL)**
    - 사용자의 추가 요청이나 질문, 메모는 **`user_needs.md`** 파일에 기록하는 것을 원칙으로 한다.
    - 작업 세션 시작 시 `progress.yml`과 함께 이 파일을 확인하여 사용자의 요구사항을 파악하고 작업 계획에 반영한다.

- **M-04: 문서 최신화 (CRITICAL)**
    - 코드 수정으로 인해 프로그램의 동작, 빌드 방법, 사용법 등에 변경이 발생한 경우, 관련된 모든 문서(`gemini.md`, `specification.md` 등)를 즉시 찾아 최신 상태로 업데이트해야 한다.
    - 이는 다음 작업자가 변경 사항을 명확히 인지하고, 문서와 실제 코드 간의 불일치로 인한 혼란을 방지하기 위함이다.

- **M-05: Gemini 에이전트 소통 기록 (CRITICAL)**
    - Gemini 에이전트와의 모든 장문 소통 및 지시사항은 **`user_chat.txt`** 파일에 기록하는 것을 원칙으로 한다.
    - 이 파일은 작업 세션 간의 연속성을 유지하고, 중요한 결정 사항이나 지시를 추적하는 데 사용된다.

---

## 6. Gemini 에이전트 상호작용 지침

이 섹션은 Gemini 에이전트와의 효율적이고 명확한 상호작용을 위한 지침을 명시합니다.

1.  **간결한 핵심 전달**: 답변 시 서론이나 부연 설명은 최소화하고, 질문의 요지에 대한 답변이나 해결책을 즉시 제시한다.
2.  **근본 원인 심층 분석**: 문제가 발생했을 때 '인코딩', '라이브러리 버전' 등 환경적 요인을 먼저 추측하지 않는다. 대신, 코드의 논리적 흐름, 데이터의 전달 과정, 함수 호출 관계 등 소프트웨어 내부의 근본적인 원인을 우선적으로 심층 분석한다.
3.  **문제 시 원점 회귀 및 비교**: 제안한 방법으로 문제가 해결되지 않거나 상황이 더 복잡해지면, 추가적인 변경을 시도하지 않고 즉시 변경 전 상태(원점)로 돌아간다. 이후, 문제가 없었던 백업 또는 이전 버전의 코드를 참조하여 변경점을 비교 분석함으로써 원인을 찾는다.
4.  **사용자 승인 기반의 작업 수행**: 코드 수정, 파일 변경, 명령어 실행 등 시스템에 변화를 주는 모든 작업은 반드시 사용자에게 먼저 제안하고 명확한 승인을 받아야 한다. "실행해보자"는 식의 제안이 아닌, "이러한 변경을 제안합니다. 승인하시면 실행하겠습니다." 와 같이 작업의 결정권을 사용자에게 넘긴다.
