# [HANTEC ERP] 파워빌더 10 -> 10.5 마이그레이션 핸드북

## 0. 문서 개요

이 문서는 한텍 ERP 시스템의 파워빌더 10 버전을 10.5로 마이그레이션하는 프로젝트의 전반적인 지침과 결과물을 관리하는 핸드북입니다.

- **주요 구성 (작업 흐름)**:
    1.  **핵심 대원칙**: 프로젝트의 기본 원칙을 숙지합니다.
    2.  **패턴 분석 원칙**: 소스 코드 분석 및 패턴 정의의 기준을 정립합니다.
    3.  **마이그레이션 최종 패턴**: 분석된 패턴을 목록화하고 상세 내용을 정의합니다.
        `->` 이 패턴들은 `PBMigrator` 개발의 핵심 명세가 됩니다.
    4.  **PBMigrator**: 정의된 패턴에 따라 마이그레이션을 자동화하는 도구의 사용법과 명세를 안내합니다.
    5.  **작업 관리**: 모든 작업의 이력을 추적하고 관리하는 방법을 안내합니다.

- **핵심 목표**:
    - 모든 소스 코드가 새로운 파워빌더 10.5 환경에서 완벽하게 호환되도록 보장합니다.
    - 자동화된 마이그레이션을 통해 작업의 일관성과 효율성을 극대화합니다.

---



## 1. 핵심 대원칙

> **"기존 로직과 기능에 단 1%의 변경도 없이, 새 버전(10.5)에서 완벽하게 호환되도록 한다."**

- **파워빌더 10.5 문법 준수**: 모든 코드는 파워빌더 10.5 문법에 맞게 작성되어야 하며, 이로 인해 발생하는 `Syntax Error`는 없어야 한다.
- **최소 변경의 원칙**: '개선'이 아닌 '호환'을 목표로 한다. 기능 및 로직에 영향을 줄 수 있는 임의의 코드 수정, 구조 변경, 리팩토링을 **절대 금지**한다.
- **참조용 소스 보호**: `source/_sample`, `source/_reference`, `target/_sample`, `target/_reference` 폴더의 파일들은 패턴 분석을 위한 원본 참조 자료이므로, 마이그레이션 작업 중 절대로 수정되어서는 안 된다.
- **변경 유형 제한**: 오직 **Type 1** 변경만 허용한다.
    - **Type 1 (호환성 수정)**: 인코딩, 줄바꿈, 미지원 함수 등 실행 환경 변화로 인해 발생하는 컴파일/실행 오류를 해결하기 위한 **필수 수정**.
    - **Type 2 (임의 개선)**: 상속 구조 변경, UI 패턴 통일, 로직 '개선' 등 기존 동작에 영향을 줄 수 있는 모든 **임의 수정. (원칙적 금지)**

---

## 2. 패턴 분석 원칙

1.  **실행 코드 기반 분석**: 오직 **실행되는(Active) 코드**의 변경점만을 패턴 분석의 근거로 삼는다. 주석 처리된 코드는 분석에서 제외한다.
2.  **반복성 교차 검증**: 하나의 파일에서 발견된 변경 유형은, 최소 **2개 이상의 다른 파일**에서 동일한 규칙으로 반복되는지 교차 검증을 거친 후에만 패턴으로 정의한다.
3.  **사실 기반의 명확한 근거 제시**: 추측이나 부정확한 기억이 아닌, 실제 파일의 내용에만 100% 기반하여 패턴을 도출하고 설명한다.

---

## 3. 마이그레이션 최종 패턴

### 3.1. [Level 0] 파일 형식 (Physical Layer)
- **P-01: 인코딩 & 줄바꿈 (CRITICAL)**
    - 모든 `.srw` 파일은 **UTF-16 LE** 인코딩과 **CRLF** (`\r\n`) 줄바꿈으로 저장해야 합니다. (IDE Crash 방지)

### 3.2. [Level 1] 윈도우 선언부 (Structural Layer)
- **P-02: 상속 컨트롤 재정의 (CRITICAL)**
    - 부모 윈도우(`w_inherite`)로부터 상속받은 컨트롤의 속성을 변경(예: 숨기기)할 때는 `type...end type` 블록만 사용합니다.
    - **숨김 처리**: `visible = false` 속성은 오류를 유발하므로 **사용하지 않습니다.** 대신 `x`, `y` 좌표를 윈도우 화면 밖의 큰 값으로 지정하여 이동시킵니다. 이는 **P-08**의 MDI 표준 이벤트가 기존 컨트롤의 로직을 재사용하기 때문입니다.
    - **중복 선언 금지**: 상속받은 컨트롤은 이미 윈도우에 존재하는 것이므로, 변수 선언부에서 다시 선언(`p_mod p_mod`)하거나 `create`/`destroy` 이벤트에서 생성/삭제해서는 **절대 안 됩니다.** (C0088: Duplicate property name 오류 발생)

- **P-03: 사용자 이벤트 프로토타입 선언**
    - 윈도우에서 사용하는 모든 사용자 정의 이벤트(예: `ue_query`, `ue_add`)는 `forward prototypes` 섹션에 명시적으로 선언해야 합니다.
    - **(오류 원인)**: 선언이 누락되면 컴파일 시 `Unknown function name` 오류가 발생합니다.

- **P-04: 표준 이벤트 스크립트 추가 (확장)**
    - **`resize` 이벤트**: **P-07**에 따라 새로 추가된 `Rectangle` 레이아웃 컨트롤(`r_head`, `r_detail` 등)에 맞춰 내부 컨트롤들의 크기와 위치를 동적으로 재배치하는 표준 스크립트를 작성합니다.
    - **`activate` 이벤트**: `w_inherite`를 상속받는 윈도우의 경우, `activate` 이벤트에서 MDI 공통 툴바의 버튼 상태(활성/비활성)를 제어하는 표준 스크립트를 작성합니다.

### 3.3. [Level 2] 컨트롤 및 스크립트 (Content Layer)
- **P-05: 불필요한 장식용 컨트롤 삭제**
    - 미적 용도로만 사용되는 레거시 그래픽 컨트롤(RoundRectangle, Line, GroupBox 등)은 삭제합니다.
    - 대상: `rr_*` (RoundRectangle), `ln_*` (Line), `gb_*` (GroupBox) 등.
    - **주의**: 이 컨트롤들은 **P-07**의 새로운 `Rectangle` 기반 레이아웃으로 대체됩니다.

- **P-06: 깨진 한글 수정**
    - 주석, 컨트롤의 `text` 속성, DataWindow 객체 내부 등에서 깨진 한글을 모두 정상적으로 복원합니다.

- **P-09: `GetFocus()` 타입 안전성 확보 (CRITICAL)**
    - **(문제점)**: `GetFocus()` 함수를 사용하는 스크립트에서 반환된 `GraphicObject`가 특정 컨트롤 타입(예: DataWindow)일 것이라고 가정하고 후속 처리를 하는 경우가 많습니다. 이는 런타임 시점에 실제 포커스된 컨트롤 타입과 불일치하여 오류를 발생시킬 수 있습니다.
    - **(해결책)**: `GetFocus()`가 반환한 객체의 속성이나 함수에 접근하기 전, `TypeOf()` 함수를 사용하여 객체의 타입을 반드시 확인합니다. 타입이 일치하지 않을 경우, 오류가 발생하지 않도록 분기 처리(예: `return`)를 추가하여 코드의 안정성을 높입니다.
    - **(코드 예시)**
        ```powerbuilder
        // AS-IS: 포커스된 객체가 DataWindow가 아닐 경우 에러 발생
        GraphicObject lo_obj
        lo_obj = GetFocus()
        lo_obj.AcceptText()

        // TO-BE: TypeOf()로 타입을 확인하여 런타임 오류 방지
        GraphicObject lo_obj
        lo_obj = GetFocus()
        if TypeOf(lo_obj) = DataWindow! then
            lo_obj.AcceptText()
        end if
        ```

- **P-10: 레거시 캘린더 컨트롤 교체 (CRITICAL)**
    - **(문제점)**: 일부 레거시 윈도우에서 `u_pb_cal`이라는 사용자 정의 객체를 사용하여 날짜 선택(캘린더) 버튼을 구현했습니다. 이 컨트롤은 새로운 UI 디자인과 맞지 않고, 기능적으로도 개선이 필요합니다.
    - **(해결책)**: `u_pb_cal` 컨트롤을 새로운 표준 컨트롤인 `u_pic_cal`으로 교체합니다. `u_pic_cal`은 `Picture` 컨트롤 기반으로, 현대적인 아이콘과 통일된 이벤트 처리 방식을 제공합니다. 이 변경은 UI/UX 개편(P-07)의 일환으로 진행됩니다.
    - **(코드 예시)**
        ```powerbuilder
        // AS-IS:
        type pb_1 from u_pb_cal within w_pdm_11740

        // TO-BE:
        type pb_1 from u_pic_cal within w_pdm_11740
        ```

- **P-11: `ue_retrieve` 이벤트 내 업무별 조회 로직 추가 (CRITICAL)**
    - **(문제점)**: 기존의 조회 로직은 모든 사용자에 대해 동일하게 동작했습니다. 새로운 시스템에서는 특정 업무(`is_Upmu = 'A'`)를 수행하는 사용자에 대해 조회 범위를 동적으로 변경해야 하는 요구사항이 추가되었습니다.
    - **(해결책)**: `ue_retrieve` 이벤트의 시작 부분에 `is_Upmu` 변수를 확인하는 분기문을 추가합니다. `is_Upmu`가 'A'일 경우, `SYSCNFG` 테이블을 조회하여 `sabu_f`와 `sabu_t` 값을 설정하고, 이를 조회 조건으로 활용합니다. 이는 MDI 환경에서 사용자 권한 및 업무 구분에 따른 데이터 조회를 표준화하기 위한 필수적인 로직입니다.
    - **(코드 예시)**
        ```powerbuilder
        // In ue_retrieve event:
        if is_Upmu = 'A' then
        	if dw_ip.AcceptText() = -1 then return  

        	w_mdi_frame.SetMicroHelp("") 
        	
        	sabu_f =Trim(dw_ip.GetItemString(1,"saupj"))
        	
        	SetPointer(HourGlass!)
        	IF sabu_f ="" OR IsNull(sabu_f) OR sabu_f ="99" THEN
        		sabu_f ="10"
        		sabu_t ="98"
        		SELECT "REFFPF"."RFNA1"  
        		 INTO :sabu_nm  
        		 FROM "REFFPF"  
        		WHERE ( "REFFPF"."RFCOD" = 'AD' ) AND  
        				( "REFFPF"."RFGUB" = '99' )   ;
        	ELSE
        		sabu_t =sabu_f
        		SELECT "REFFPF"."RFNA1"  
        		 INTO :sabu_nm  
        		 FROM "REFFPF"  
        		WHERE ( "REFFPF"."RFCOD" = 'AD' ) AND  
        				( "REFFPF"."RFGUB" = :sabu_f )   ;
        	END IF
        end if

        // Original retrieve logic follows...
        ```

### 3.4. [Level 3] UI/UX 현대화 (UI/UX Modernization Layer)
- **P-07: UI/UX 전면 개편 (CRITICAL)**
    - **목표**: 모든 윈도우에 일관된 최신 UI/UX 템플릿을 적용합니다.
    - **레이아웃 재구성**: 기존의 불규칙한 컨트롤 배치를 버리고, `r_head`(상단 영역), `r_detail`(상세 영역) 등 명명된 `Rectangle` 컨트롤을 사용하여 화면을 구조적으로 분할합니다.
    - **컨트롤 재배치**: 모든 데이터윈도우, 버튼 등의 컨트롤은 새로 생성된 `Rectangle` 영역에 맞춰 위치와 크기가 재조정됩니다.
    - **장식 컨트롤 교체**: **P-05**에 따라 삭제된 `RoundRectangle` 등의 장식 컨트롤을 대체하여, `Rectangle` 컨트롤이 새로운 시각적 구조를 형성합니다.

- **P-08: 표준 MDI 이벤트 연동 (CRITICAL)**
    - **목표**: 윈도우 내부의 버튼 이벤트를 MDI 공통 툴바와 연동합니다.
    - **표준 사용자 이벤트 추가**: `ue_retrieve`(조회), `ue_update`(수정), `ue_delete`(삭제), `ue_append`(추가) 등 MDI 툴바의 기능과 일치하는 표준 사용자 이벤트를 윈도우에 추가합니다.
    - **이벤트 호출 체인**: MDI 툴바 버튼 클릭 -> 윈도우의 표준 사용자 이벤트(`ue_*`) 트리거 -> 해당 이벤트의 스크립트가 기존에 숨겨진 `PictureButton`(`p_inq`, `p_mod` 등)의 `Clicked` 이벤트를 호출합니다. 이를 통해 기존 로직을 수정 없이 재사용합니다.

---

## 4. PBMigrator: 자동 마이그레이션 도구

### 4.1. 개발 목표 및 현황

- **목표**: `specification.md` 명세서에 따라, PowerBuilder 10 소스를 10.5 버전으로 자동 변환하는 GUI 애플리케이션 `PBMigrator`를 개발한다.
- **핵심 역할**:
    - `gemini.md`의 **'3. 마이그레이션 최종 패턴'** 에 정의된 모든 규칙을 자동화하여 적용한다.
    - 사용자가 변환 과정을 시각적으로 확인하고 제어할 수 있는 UI를 제공한다.
- **작업 상태**: `source/_sample` 폴더의 신규 소스 분석을 통해 마이그레이션 패턴을 지속적으로 개선하고 있으며, 발견된 패턴을 `PBMigrator` 엔진에 반영하는 작업을 진행 중입니다.

### 4.2. 사용법

모든 마이그레이션 작업은 `PBMigrator` GUI 프로그램을 통해 진행하는 것을 원칙으로 한다.

**1단계: 프로그램 실행 및 파일 선택**
- `dist` 폴더의 `PBMigrator.exe`를 실행하여 프로그램을 시작한다.
- 프로그램은 시작 시 자동으로 `source` 폴더 하위의 모든 `.srw` 파일을 읽어 좌측 '파일 목록'을 채운다. (`_`로 시작하는 폴더는 제외)
- 목록에서 변환할 파일을 한 개 또는 여러 개 선택한다.

**2단계: 변환 실행 (두 가지 방법)**

**방법 A: 단일 파일 변환 (즉시 확인 및 저장)**
1.  '파일 목록'에서 **하나의 파일**을 선택한다.
2.  '설정 및 실행' 탭의 우측 하단에 있는 원본 코드 뷰어에 해당 파일의 내용이 표시되는 것을 확인한다.
3.  **'소스 비교' 탭을 클릭한다.**
4.  탭을 클릭하는 즉시, 선택된 파일에 대한 변환이 자동으로 실행되고 `target` 폴더에 저장된다.
5.  '소스 비교' 탭으로 자동 전환되며, 좌측(원본)과 우측(변환 후)의 코드 비교 결과를 즉시 확인할 수 있다.
6.  상세한 변환 내역은 '설정 및 실행' 탭의 'Log' 창에 표시된다.

**방법 B: 일괄 변환 (여러 파일 동시 처리)**
1.  '파일 목록'에서 **여러 개의 파일**을 선택한다. (Ctrl 또는 Shift 키 사용)
2.  '설정 및 실행' 탭의 'Controls' 영역 우측에 있는 **[변환 실행]** 버튼을 클릭한다.
3.  진행률을 표시하는 팝업창이 나타나며, 선택된 모든 파일에 대한 변환 및 저장이 순차적으로 진행된다.
4.  모든 작업이 완료되면, 'Log' 창에 모든 파일에 대한 상세한 변환 결과가 한 번에 출력된다.

**3단계: 결과 확인**
- **변환된 파일**: `target` 폴더에 원본과 동일한 경로 구조로 변환된 `.srw` 파일이 생성된다. (P-01 규칙에 따라 UTF-16 LE, CRLF로 저장됨)
- **처리 로그**: 'Log' 창에서 각 파일의 규칙 적용 내역, 성공/실패 여부 등 상세한 정보를 확인할 수 있다. (별도의 `.md` 보고서 파일은 더 이상 생성되지 않음)

### 4.3. 빌드 및 재배포

`PBMigrator`의 소스 코드를 수정한 후, 사용자가 직접 실행할 수 있는 `.exe` 파일을 만들려면 `PBMigrator.spec` 파일을 사용하여 빌드를 진행합니다.

**빌드 절차**

1.  **전제 조건**: 로컬 시스템에 **Python**과 **PyInstaller** 라이브러리가 설치되어 있어야 합니다.
2.  **빌드 실행**: 프로젝트 최상위 폴더(`hantec_erp_gemini`)에서 다음 명령어를 실행합니다. `PBMigrator.spec` 파일에는 필요한 모든 빌드 설정이 이미 포함되어 있습니다.

    ```shell
    py -m PyInstaller PBMigrator.spec
    ```

3.  **결과 확인**: 빌드가 성공하면 `dist` 폴더에 `PBMigrator.exe` 파일이 생성됩니다.

**중요 사항**:
- 빌드 실패 시 `PermissionError`가 발생한다면, 이전에 실행했던 `PBMigrator.exe`가 종료되지 않았거나 다른 프로그램이 파일을 잠근 상태일 수 있습니다. `dist` 폴더의 `.exe` 파일을 수동으로 삭제한 후 다시 빌드를 시도하십시오.

---

## 5. 작업 관리 (Management)

- **M-01: 버전 관리 (CRITICAL)**
    - 모든 작업 완료 후, 변경 사항은 반드시 GitHub 저장소에 업로드(Push)하여 최신 상태를 유지한다.
    - **`main` 브랜치를 단일 브랜치로 사용하며, 다른 브랜치(예: `master`)는 생성하거나 사용하지 않는다.**
    - `source`와 `target` 폴더는 모두 버전 관리 대상으로, 변환 전 원본과 변환 후 결과물을 함께 추적하여 관리한다.

- **M-02: 진행 상황 기록 (CRITICAL)**
    - 모든 작업 내역은 **`progress.yml`** 파일에 YAML 형식으로 기록하여 관리한다.
    - 각 작업은 `PBMigrator` 실행 단위(파일 변환 및 저장) 또는 주요 결정 사항을 기준으로 로그가 기록된다.
    - 각 로그 항목은 `timestamp`, `status`, `target`, `description`, `worker` 등의 정보를 포함한다.
    - **새 작업 세션 시작 시, 가장 먼저 이 파일을 확인하여 마지막 작업 상태를 파악하고 다음 작업을 결정한다.**

- **M-03: 사용자 요청사항 관리 (CRITICAL)**
    - 사용자의 추가 요청이나 질문, 메모는 **`user_notes.md`** 파일에 기록하는 것을 원칙으로 한다.
    - 작업 세션 시작 시 `progress.yml`과 함께 이 파일을 확인하여 사용자의 요구사항을 파악하고 작업 계획에 반영한다.

- **M-04: 문서 최신화 (CRITICAL)**
    - 코드 수정으로 인해 프로그램의 동작, 빌드 방법, 사용법 등에 변경이 발생한 경우, 관련된 모든 문서(`gemini.md`, `specification.md` 등)를 즉시 찾아 최신 상태로 업데이트해야 한다.
    - 이는 다음 작업자가 변경 사항을 명확히 인지하고, 문서와 실제 코드 간의 불일치로 인한 혼란을 방지하기 위함이다.